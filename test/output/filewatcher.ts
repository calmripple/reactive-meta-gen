/* eslint-disable */
// This file is generated by `reactive-meta-gen`. Do not modify manually.
// @see https://github.com/calmripple/reactive-meta-gen
// Meta info
import { defineConfigObject, defineConfigs, useCommand as useReactiveCommand, useCommands as useReactiveCommands, useLogger as useReactiveLogger, useOutputChannel as useReactiveOutputChannel, useStatusBarItem, useDisposable, } from 'reactive-vscode';
export const publisher = "appulate";
export const name = "filewatcher";
export const version = "2.0.0";
export const displayName = "File Watcher";
export const description = "Watch file or folder changes (deletions, creations, renaming), and run matched command scripts.";
export const extensionId = "appulate.filewatcher";
type Cache<T> = Record<string, {
    exp: number | null;
    value: T;
    dispose: () => void;
}>;
const memoize = <TArgs extends any[], TResult>(cache: Cache<TResult>, func: (...args: TArgs) => TResult, keyFunc: ((...args: TArgs) => string) | null, ttl: number | null) => {
    return function callWithMemo(...args: any): TResult {
        const key = keyFunc ? keyFunc(...args) : JSON.stringify({ args });
        const existing = cache[key];
        if (existing !== undefined) {
            if (!existing.exp)
                return existing.value;
            if (existing.exp > new Date().getTime()) {
                return existing.value;
            }
        }
        const result = func(...args);
        cache[key] = {
            exp: ttl ? new Date().getTime() + ttl : null,
            value: result,
            dispose: () => {
                delete cache[key];
            }
        };
        useDisposable(cache[key]);
        return result;
    };
};
/**
 * Creates a memoized function. The returned function
 * will only execute the source function when no value
 * has previously been computed. If a ttl (milliseconds)
 * is given previously computed values will be checked
 * for expiration before being returned.
 */
export const memo = <TArgs extends any[], TResult>(func: (...args: TArgs) => TResult, options: {
    key?: (...args: TArgs) => string;
    ttl?: number;
} = {}) => {
    return memoize({}, func, options.key ?? null, options.ttl ?? null) as (...args: TArgs) => TResult;
};
export interface CommandsInformation {
    /**
     *  category string by which the command is grouped in the UI
     */
    category?: string;
    /**
     * identifier of the command to execute
     */
    command: string;
    /**
     * title which the command is represented in the UI
     */
    title: string;
    enablement?: string;
    icon?: string;
    shortTitle?: string;
    commandShorthandName?: string;
}
/**
 * Type union of all commands
 */
export type Command = "extension.enableFileWatcher" | "extension.disableFileWatcher" | "extension.focusIntoOutput";
/**
 * Commands map registed by `appulate.filewatcher`
 */
export const commands = {
    /**
     * File Watcher: Enable
     * @command `extension.enableFileWatcher`
     */
    enableFileWatcher: "extension.enableFileWatcher",
    /**
     * File Watcher: Disable
     * @command `extension.disableFileWatcher`
     */
    disableFileWatcher: "extension.disableFileWatcher",
    /**
     * File Watcher: Focus Output
     * @command `extension.focusIntoOutput`
     */
    focusIntoOutput: "extension.focusIntoOutput",
} satisfies Record<string, Command> as Record<string, Command>;
/**
 * Commands map registed by `appulate.filewatcher`
 */
export const commandsInformation = {
    /**
     * File Watcher: Enable
     * @command `extension.enableFileWatcher`
     */
    "extension.enableFileWatcher": { "commandShorthandName": "enableFileWatcher", "command": "extension.enableFileWatcher", "title": "File Watcher: Enable" },
    /**
     * File Watcher: Disable
     * @command `extension.disableFileWatcher`
     */
    "extension.disableFileWatcher": { "commandShorthandName": "disableFileWatcher", "command": "extension.disableFileWatcher", "title": "File Watcher: Disable" },
    /**
     * File Watcher: Focus Output
     * @command `extension.focusIntoOutput`
     */
    "extension.focusIntoOutput": { "commandShorthandName": "focusIntoOutput", "command": "extension.focusIntoOutput", "title": "File Watcher: Focus Output" },
} satisfies Record<Command, CommandsInformation> as Record<Command, CommandsInformation>;
/**
 * Register a command. See `vscode::commands.registerCommand`.
 */
export const useCommand = (commandFullKey: Command, callback: (...args: any[]) => any): void => useReactiveCommand(commandFullKey, callback);
/**
 * Register multiple commands. See `vscode::commands.registerCommand`.
 */
export const useCommands = (commands: Partial<Record<Command, (...args: any[]) => any>>): void => useReactiveCommands(commands);
/**
 * Name type of Logger and OutputChannel
 */
export type LoggerName = typeof name | typeof displayName | typeof extensionId;
/**
 * Creates a logger that writes to the output channel.
 */
export const useLogger = (loggerName: LoggerName = displayName ?? name ?? extensionId, getPrefix?: ((type: string) => string) | null) => useReactiveLogger(loggerName, { 'getPrefix': getPrefix });
/**
 * @reactive `window.createOutputChannel`
 */
export const useOutputChannel = (outputName: LoggerName = displayName ?? name ?? extensionId) => useReactiveOutputChannel(outputName);
/**
 * Create a statusBarItem with a commmand id
 */
export const useStatusBarItemFromCommand = memo((commandKey: Command) => {
    let cmd = commandsInformation[commandKey];
    return useStatusBarItem({
        id: cmd.commandShorthandName,
        command: cmd.command,
        name: cmd.command,
        text: cmd.shortTitle ?? cmd.title,
        tooltip: cmd.title
    });
});
/**
 * File Watcher: Enable
 * @command Register a command `extension.enableFileWatcher`
 */
export const useCommandEnableFileWatcher = (callback: (...args: any[]) => any) => useCommand(commands.enableFileWatcher, callback);
/**
 * File Watcher: Disable
 * @command Register a command `extension.disableFileWatcher`
 */
export const useCommandDisableFileWatcher = (callback: (...args: any[]) => any) => useCommand(commands.disableFileWatcher, callback);
/**
 * File Watcher: Focus Output
 * @command Register a command `extension.focusIntoOutput`
 */
export const useCommandFocusIntoOutput = (callback: (...args: any[]) => any) => useCommand(commands.focusIntoOutput, callback);
/**
 * Section Type of `filewatcher`
 */
export interface Filewatcher {
    /**
     * Automatically clear the console on each save before running commands.
     */
    "autoClearConsole": boolean;
    /**
     * Common shell to execute the command with (gets passed to child_process.exec as an options arg. e.g. child_process(cmd, { shell }).
     */
    "shell"?: (string | undefined);
    /**
     * Returns the status bar to its normal position (after receiving a 'Success' or 'Error' status) after a some time.
     */
    "isClearStatusBar": boolean;
    /**
     * The time after which the status returns to normal. Only works if isClearStatusBar === true. Default is 5000ms
     */
    "statusBarDelay": number;
    /**
     * Launches event handlers of the same name with the appropriate pattern 'match' or 'notMatch' (e.g. onFileChange and onFolderChange) in synchronous or asynchronous mode.
     */
    "isSyncRunEvents": boolean;
    /**
     * Color for success message in the status bar. Default: dark: '#25E028', light: '#18CE1B', highContrast: '#0DC610'
     */
    "successTextColor"?: (string | undefined);
    /**
     * Color for run message in the status bar. Default: dark: '#00FFFB', light: '#02D4D1', highContrast: '#03D2CE'
     */
    "runTextColor"?: (string | undefined);
    /**
     * Array of commands
     */
    "commands": ({
        /**
     * Unique shell to execute the command with (gets passed to child_process.exec as an options arg. e.g. child_process(cmd, { shell }).
     * @default `undefined`
     */
        'shell'?: string;
        /**
         * Regex for matching files to run commands on
         *
         * NOTE: This is a regex and not a file path spce, so backslashes have to be escaped. They also have to be escaped in json strings, so you may have to double escape them in certain cases such as targetting contents of folders.
         *
         * e.g.
         * "match": "some\\\\directory\\\\.*"
         * @default `".*"`
         */
        'match': string;
        /**
         * Regex for matching files *not* to run commands on.
         * @default `".*"`
         */
        'notMatch': string;
        /**
         * Command to execute.
         * @default `"echo ${file}"`
         */
        'cmd': string;
        /**
         * Name of a VS Code task defined in tasks.json or commands to execute. Only works if cmd value does not exist. Must be a string (e.g. command id) or array of strings (e.g. ['workbench.action.tasks.runTask', 'some-task-name'] and etc.)
         * @default `undefined`
         */
        'vscodeTask'?: string | string[];
        /**
         * Run command asynchronously.
         * @default `undefined`
         */
        'isAsync'?: boolean;
        /**
         * Events onFileChange, onFileChangeImmediate, onFileDelete, onFileRename, onFileCreate, onFolderChange, onFolderCreate, onFolderDelete
         * @default `undefined`
         */
        'event'?: ("onFileChange" | "onFileChangeImmediate" | "onFolderChange" | "onFileDelete" | "onFileRename" | "onFileCreate" | "onFolderCreate" | "onFolderDelete");
    }[] | undefined);
}
const filewatcherDefaults = {
    /**
     * Config defaults of `filewatcher`
     */
    "filewatcher": {
        /**
         * Automatically clear the console on each save before running commands.
         */
        "autoClearConsole": false,
        /**
         * Common shell to execute the command with (gets passed to child_process.exec as an options arg. e.g. child_process(cmd, { shell }).
         */
        "shell": undefined,
        /**
         * Returns the status bar to its normal position (after receiving a 'Success' or 'Error' status) after a some time.
         */
        "isClearStatusBar": false,
        /**
         * The time after which the status returns to normal. Only works if isClearStatusBar === true. Default is 5000ms
         */
        "statusBarDelay": 5000,
        /**
         * Launches event handlers of the same name with the appropriate pattern 'match' or 'notMatch' (e.g. onFileChange and onFolderChange) in synchronous or asynchronous mode.
         */
        "isSyncRunEvents": false,
        /**
         * Color for success message in the status bar. Default: dark: '#25E028', light: '#18CE1B', highContrast: '#0DC610'
         */
        "successTextColor": undefined,
        /**
         * Color for run message in the status bar. Default: dark: '#00FFFB', light: '#02D4D1', highContrast: '#03D2CE'
         */
        "runTextColor": undefined,
        /**
         * Array of commands
         */
        "commands": [],
    } satisfies Filewatcher as Filewatcher,
};
export type ConfigurationSection = keyof typeof filewatcherDefaults;
/**
 * Shorthand of config section name.
 */
export const configs = {
    filewatcher: "filewatcher",
} satisfies Record<string, ConfigurationSection>;
/**
 * Define configurations of an extension. See `vscode::workspace.getConfiguration`.
 */
export const useConfig = memo(<K extends ConfigurationSection>(section: K) => defineConfigs<typeof filewatcherDefaults[K]>(section, filewatcherDefaults[section]));
/**
 * Define configurations of an extension. See `vscode::workspace.getConfiguration`.
 */
export const useConfigObject = memo(<K extends ConfigurationSection>(section: K) => defineConfigObject<typeof filewatcherDefaults[K]>(section, filewatcherDefaults[section]));
/**
 * ConfigObject of `filewatcher`
 */
export const useConfigObjectFilewatcher = () => useConfigObject(configs.filewatcher);
/**
 * ToConfigRefs of `filewatcher`
 */
export const useConfigFilewatcher = () => useConfig(configs.filewatcher);
